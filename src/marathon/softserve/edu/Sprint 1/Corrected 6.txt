import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;



public abstract class Shape {

	private String name;

	public Shape(String name) {
		super();
		this.name = name;
	}

	public Shape() {
	}

	public String getName() {
		return name;
	}
	
	public abstract double getArea();

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Shape other = (Shape) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	
	
}

class Circle extends Shape {

	private double radius;
	
	public Circle(String name, double radius) {
		super(name);
		this.radius = radius;
	}

	public Circle(double radius) {
		super();
		this.radius = radius;
	}
	
	public Circle() {
		super();	
	}

	public double getRadius() {
		return radius;
	}
	
	@Override
	public double getArea() {
		return (Math.PI * (radius * 2));
	}

	@Override
	public String toString() {
		return "Circle [radius=" + radius + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		long temp;
		temp = Double.doubleToLongBits(radius);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!super.equals(obj))
			return false;
		if (getClass() != obj.getClass())
			return false;
		Circle other = (Circle) obj;
		if (Double.doubleToLongBits(radius) != Double.doubleToLongBits(other.radius))
			return false;
		return true;
	}	
	
}


class Rectangle extends Shape {
	private double height;
	private double width;
	
	public Rectangle(String name, double height, double width) {
		super(name);
		this.height = height;
		this.width = width;
	}

	public Rectangle(double height, double width) {
		super();
		this.height = height;
		this.width = width;
	}
	
	public Rectangle() {
		super();	
	}

	public double getHeight() {
		return height;
	}
	
	public double getWidth() {
		return width;
	}
	
	@Override
	public double getArea() {
		return height * width;
	}

	@Override
	public String toString() {
		return "Rectangle [height=" + height + ", width=" + width + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		long temp;
		temp = Double.doubleToLongBits(height);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(width);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!super.equals(obj))
			return false;
		if (getClass() != obj.getClass())
			return false;
		Rectangle other = (Rectangle) obj;
		if (Double.doubleToLongBits(height) != Double.doubleToLongBits(other.height))
			return false;
		if (Double.doubleToLongBits(width) != Double.doubleToLongBits(other.width))
			return false;
		return true;
	}
	
}

class MyUtils {

	public List<Shape> maxAreas(List<Shape> shapes) {
		List<Shape> sortShapes = new ArrayList<>(shapes);
		if (shapes ==null) {
			return null;
		} 
		if(shapes.size()==0) {
			return shapes;
		}
		AreaComparator comparator = new AreaComparator();
		Map<String, List<Shape>> maxShapes = new HashMap<>();
		Collections.sort(sortShapes, comparator);
		for(Shape shape : sortShapes) {
			String key = shape != null ? shape.getName() : null;
			List<Shape> list = maxShapes.get(key);
			if(list ==null) {
				list = new ArrayList<>();
				list.add(shape);
			}
			Shape start = list.get(0);
			if((start != null)
				&& (!start.equals(shape))
				&& (comparator.compare(start, shape) == 0)) {
				list.add(shape);
			}
			maxShapes.put(key, list);
		}
		
		List<Shape> result = new ArrayList<>();
		for(Map.Entry<String, List<Shape>> entry : maxShapes.entrySet()) {
			result.addAll(entry.getValue());
		}
		return result;
	}

}

class AreaComparator implements Comparator<Shape> {
	@Override
	public int compare(Shape o1, Shape o2) {
		if(o1==null && o2 ==null) {
			return 0;	
		} else if (o1 == null) {
			return -1;
		} else if (o2 == null) {
			return 1;
		}
		double result = o1.getArea() - o2.getArea();
		if (Math.abs(result) < 0.000001) {
			return 0;
		}
		while (Math.abs(result) < 1) {
			result = result * 10;
		}
		return -(int) result;
	}
}
